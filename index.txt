Cell is a domain-specific programming language designed to integrate with your language of choice and to deal with a number of issues conventional languages have no satisfying solutions for.

It offers, among other things, a very flexible, entirely structural type system; deterministic, repeatable execution; support for reactive programming; the ability to use relations to store data; transactions and propagation of undefined values for error handling; and ortogonal persistence.

Cell's most important new language construct is automata, which come in two flavors: static automata and reactive ones.

A reactive automaton can be regarded as a sort of "reactive object". It has inputs, outputs and a state. It reacts to changes in the values of the inputs by adjusting its state. The outputs, at any given time, are a (pure) function of the current values of the inputs and the state. The state is adjusted one layer at a time, in a specific order, starting with those state variables that only depend on the inputs, then gradually propagating the changes all the way from the inputs to the outputs. The whole process is entirely deterministic, and therefore repeatable: if two instances of a given automaton are fed the same sequence of inputs, they will always produce the same sequence of outputs, and they will go through the same sequence of states. Changes in the state of an automaton can also be triggered, even in the absence of changes in the values of the inputs, by the simple passing of time.
Whenever an error occurs during the calculation of the new value of a state variable (or an output), that variable and all the ones that depend on it, directly or indirectly, become undefined, until they are successfully recalculated/ASSIGNED TO AGAIN. The rest of the system, though, keeps working as usual. That way, an error in a specific subsystem of the application does not affect other subsystems that are indipendent OF it, and can even, in some cases, automatically recover over time.
Like their OOP counterparts, reactive automata can be defined incrementally, using mechanisms that are more or less the equivalent of inheritance in OO languages.

Static automata, on the other hand, have a state, which is entirely accessible to their clients in read-only mode, but no inputs nor outputs. They instead update their state in response to messages (which are not quite the same thing as inputs) sent by their clients. If the update process triggered by a message fails, that message is simply discarded and the state of the automaton is left untouched. Just like reactive ones, static automata behave deterministically: the new state of the system after an update depends only on the previous state and the message that triggered it, and, for any given starting state, any particular sequence of messages will always produce the exact same final state.
At any given time between two updates, it is possible to take a snapshot of the state of a static automaton, which can then be persisted to disk and later used to create an identical copy of it that will behave exactly like the original one. The whole process takes only a couple lines of code (in either direction) and it is totally transparent to the automata themselves. Static automata also have the ability to use relations to encode their own state, and that's by far the most important feature of the entire language.

Altough Cell is, in and of itself, a general-purpose language, that can be used to write entire applications (the Cell compiler, for example, is entirely written in Cell), that's not what it is designed for. It is, instead, meant to be used as a domain-specific language, much like, for example, tools like Lex and Yacc (or their more modern alternatives) are used for parsing: from Cell source code you can generate a set of classes in your language of choice, and use them in your existing projects. The only target language that is currently available is C++, but Java and C# are coming soon, and other languages will follow.
